
    <!DOCTYPE html>
    <html lang="de">
    <head>
        <meta charset="UTF-8">
        <title>DOKUMENTATION.md</title>
        <style>
            body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; line-height: 1.6; padding: 40px; color: #333; max-width: 900px; margin: auto; background: #f9f9f9; }
            .container { background: white; padding: 40px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
            h1 { color: #0078d4; border-bottom: 2px solid #0078d4; padding-bottom: 10px; }
            h2 { color: #005a9e; margin-top: 30px; border-left: 5px solid #0078d4; padding-left: 15px; }
            pre { background: #2d2d2d; color: #f8f8f2; padding: 15px; border-radius: 5px; overflow-x: auto; }
            table { border-collapse: collapse; width: 100%; margin: 20px 0; }
            th, td { border: 1px solid #ddd; padding: 12px; text-align: left; }
            tr:nth-child(even) { background-color: #f2f2f2; }
            th { background-color: #0078d4; color: white; }
        </style>
    </head>
    <body>
        <div class="container">
            <h1>üìÑ Hexapod Full-MCU Sensor-Stack ‚Äì Umfassende System-Dokumentation (Sim2Real Edition)</h1><p></p>**Projekt:** Hexapod RL ‚Äì Sim2Real Transition<br>**MCU Plattform:** ESP32 Dual-Core (240 MHz, Integrated FPU)<br>**Sensor-Array:** MPU6050 (IMU), GY-271/HW-246 (Magnetometer), BMP280 (Barometer), AHT20 (Klima)<br>**Zielsetzung:** Hochfrequente (500 Hz) autonome Sensor-Fusion auf der MCU zur Bereitstellung eines deterministischen RL-State-Vektors f√ºr NVIDIA Isaac Sim.<br><p></p>---<br><p></p><h2>1. System-Philosophie & Architektur</h2><p></p>Das Design folgt dem Prinzip der **minimalen Sim2Real-Divergenz**. Durch die Verlagerung der Sensor-Fusion (Madgwick AHRS) auf die MCU wird sichergestellt, dass die Orientierungsdaten unabh√§ngig von der Host-PC-Last oder Netzwerk-Jitter berechnet werden. Der ESP32 fungiert nicht als simpler Sensor-Node, sondern als **autonomer State-Processor**.<br><p></p>---<br><p></p><h2>2. Hardware-Komponenten & Spezifikationen</h2><p></p><h3>2.1 Mikrocontroller (ESP32)</h3>*   **Rechenleistung:** 240 MHz Dual-Core erm√∂glicht die parallele Ausf√ºhrung von Datenerfassung (Core 0) und komplexer Fusion/Streaming (Core 1).<br>*   **FPU-Beschleunigung:** Die integrierte Hardware-Gleitkommaeinheit ist essenziell, um den Madgwick-Filter stabil bei 500 Hz zu halten.<br>*   **Netzwerk:** UDP-Protokoll zur Vermeidung von Head-of-Line Blocking (im Gegensatz zu TCP).<br><p></p><h3>2.2 Sensor-Stack (I2C Bus 400 kHz)</h3><table><tr><td>Sensor</td><td>Funktion</td><td>Sampling</td><td>Spezifikation</td></tr><tr><td>**MPU6050**</td><td>6-Axis IMU</td><td>500 Hz</td><td>Gyro: ¬±1000¬∞/s, Acc: ¬±4g, DLPF: 42 Hz</td></tr><tr><td>**GY-271**</td><td>Magnetometer</td><td>50 Hz</td><td>Hard/Soft Iron korrigiert, Yaw-Stabilisierung</td></tr><tr><td>**BMP280**</td><td>Barometer</td><td>100 Hz</td><td>0.12 hPa Pr√§zision (ca. 1m H√∂henaufl√∂sung)</td></tr><tr><td>**AHT20**</td><td>Umwelt</td><td>50 Hz</td><td>¬±0.3¬∞C Pr√§zision zur Drift-Kompensation</td></tr><p></p></table>---<br><p></p><h2>3. Firmware-Design (Dual-Core Implementation)</h2><p></p><h3>3.1 Core 0: Hard-Real-Time Data Acquisition</h3>*   **Hardware-Timer ISR (2ms):** Ein dedizierter Interrupt-Service liest die MPU6050 FIFO-Buffer aus. Dies garantiert eine Sampling-Pr√§zision mit einem Jitter < 10¬µs.<br>*   **Sensor-Preprocessing:**<br>*   **Gyro-Korrektur:** `gyro_final = gyro_raw - (bias_static + drift_temp * T)`.<br>*   **Accel-Korrektur:** Anwendung einer 6-Positionen-Kalibriermatrix zur Eliminierung von Achsen-Fehlstellungen.<br>*   **Umwelt-Polling:** BMP280 und AHT20 werden asynchron im Main-Loop von Core 0 abgefragt und in separate FIFOs gepusht.<br><p></p><h3>3.2 Core 1: Fusion, State-Building & Streaming</h3>*   **Madgwick AHRS Engine (500 Hz):**<br>*   Fusion von Accel, Gyro und Magnetometer zu einem globalen Quaternion.<br>*   Berechnung der Linearbeschleunigung (Korrektur der Erdbeschleunigung basierend auf der aktuellen Orientierung).<br>*   **Timestamp-Synchronisation:** Core 1 korreliert die hochfrequenten IMU-Daten mit den niederfrequenten Magnetometer- und Barometer-Daten √ºber einen Nearest-Neighbor-Algorithmus im Zeitbereich.<br>*   **UDP Streaming:** √úbertragung eines bin√§ren 64-Byte Pakets (Little Endian).<br><p></p>---<br><p></p><h2>4. Kalibrierungs-Protokoll (Pr√§zisions-Vorgaben)</h2><p></p><h3>4.1 Gyroscope Bias & Thermal Drift</h3>Eine 10-sek√ºndige statische Messung beim Systemstart ermittelt den Nullpunkt-Fehler. Zur Kompensation der Erw√§rmung w√§hrend des Betriebs wird ein linearer Temperatur-Koeffizient verwendet.<br><p></p><h3>4.2 Accelerometer Non-Orthogonality</h3>Korrektur der leichten mechanischen Schiefstellung der Sensor-MEMS durch eine $3\times3$ Skalierungs- und Rotationsmatrix.<br><p></p><h3>4.3 Magnetometer Hard-Iron & Soft-Iron</h3>Eliminierung von St√∂rfeldern durch metallische Bauteile oder Motoren des Hexapods. Die Kalibrierung erfolgt durch einen 3D-Sweep des Roboters im Raum zur Erzeugung einer korrigierten Sph√§re.<br><p></p>---<br><p></p><h2>5. Sim2Real Modellierung (Isaac Sim Integration)</h2><p></p>Um das Modell in NVIDIA Isaac Sim f√ºr die Realit√§t vorzubereiten, m√ºssen folgende Noise-Profile im Simulator hinterlegt werden:<br><p></p>1.  **Gyro Noise:** Gaussian White Noise mit $\sigma \approx 0.02 - 0.05$ rad/s.<br>2.  **Gyro Bias Drift:** Random Walk Prozess zur Simulation der thermischen Drift.<br>3.  **Accel Noise:** $\sigma \approx 0.05$ m/s¬≤.<br>4.  **Network Latency:** Modellierung einer Verz√∂gerung von 5ms bis 15ms plus variablem Jitter.<br><p></p>---<br><p></p><h2>6. Kommunikationsprotokoll (Binary State Vector)</h2><p></p>Das 64-Byte UDP Paket ist wie folgt aufgebaut:<br><p></p><table><tr><td>Feld</td><td>Typ</td><td>Gr√∂√üe</td><td>Einheit</td></tr><tr><td>`timestamp_us`</td><td>uint32</td><td>4 B</td><td>Mikrosekunden</td></tr><tr><td>`gyro[3]`</td><td>float</td><td>12 B</td><td>rad/s</td></tr><tr><td>`acc[3]`</td><td>float</td><td>12 B</td><td>m/s¬≤</td></tr><tr><td>`mag[3]`</td><td>float</td><td>12 B</td><td>¬µT</td></tr><tr><td>`quaternion[4]`</td><td>float</td><td>16 B</td><td>[w, x, y, z]</td></tr><tr><td>`pressure`</td><td>float</td><td>4 B</td><td>Pascal</td></tr><tr><td>`temp`</td><td>float</td><td>4 B</td><td>Celsius</td></tr><p></p></table>---<br><p></p><h2>7. Mechanische & Elektrische Installation</h2><p></p><h3>7.1 Stromversorgung</h3>Betrieb √ºber **5V am Vin-Pin** des ESP32. Die Sensoren werden exklusiv √ºber den **3.3V Ausgang** versorgt, um eine saubere Referenzspannung zu gew√§hrleisten.<br><p></p><h3>7.2 I2C Integrit√§t</h3>*   **Pullups:** Externe 4.7kŒ© Widerst√§nde an GPIO 21/22.<br>*   **Kabelf√ºhrung:** Verdrillte Leitungen zur Unterdr√ºckung von √úbersprechen durch die PWM-Leitungen der Servos.<br>*   **D√§mpfung:** Mechanische Entkopplung der IMU vom Chassis durch 2mm TPU-D√§mpfer zur Reduktion von High-Frequency-Vibrationen der Getriebemotoren.<br>
        </div>
    </body>
    </html>
    